const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const path = require('path');

class InvoiceGenerator {
    constructor() {
        this.fonts = {
            regular: 'Helvetica',
            bold: 'Helvetica-Bold',
            italic: 'Helvetica-Oblique'
        };
        this.autoGeneratedPath = path.join(process.cwd(), 'uploads', 'invoices', 'auto-generated');
        this.adminUploadedPath = path.join(process.cwd(), 'uploads', 'invoices', 'admin-uploaded');

        // Initialize without async operations in constructor
        this.initialized = false;
    }

    // âœ… FIXED: Separate initialization method that can be awaited
    async init() {
        if (this.initialized) return;

        console.log('ðŸ“ Initializing invoice generator directories...');
        await this._ensureUploadDirectories();
        this.initialized = true;
        console.log('âœ… Invoice generator initialized successfully');
    }

    async _ensureUploadDirectories() {
        const dirs = [this.autoGeneratedPath, this.adminUploadedPath];
        for (const dir of dirs) {
            try {
                await fs.access(dir);
                console.log(`âœ… Directory exists: ${dir}`);
            } catch (error) {
                console.log(`ðŸ“ Creating directory: ${dir}`);
                await fs.mkdir(dir, { recursive: true });
                console.log(`âœ… Created directory: ${dir}`);
            }
        }
    }

    // Auto-generate invoice for purchase
    async generateAutoInvoice(order, user) {
        try {
            // âœ… FIXED: Ensure directories are ready before generating
            if (!this.initialized) {
                await this.init();
            }

            console.log('ðŸ“„ Starting auto invoice generation for order:', order.orderNumber);
            console.log('ðŸ“„ Order items count:', order.items.length);
            console.log('ðŸ“„ User:', user.email);

            const pdfBuffer = await this._createInvoicePDF(order, user);
            const fileName = `auto-invoice-${order.orderNumber}-${Date.now()}.pdf`;
            const filePath = path.join(this.autoGeneratedPath, fileName);
            const pdfUrl = `/uploads/invoices/auto-generated/${fileName}`;

            console.log('ðŸ“„ Writing PDF to:', filePath);
            await fs.writeFile(filePath, pdfBuffer);

            console.log('âœ… Invoice generated successfully:', fileName);

            return {
                pdfBuffer,
                filePath,
                fileName,
                pdfUrl,
                invoiceNumber: `INV-${order.orderNumber}-${Date.now()}`
            };
        } catch (error) {
            console.error('âŒ Invoice generation error:', error);
            console.error('âŒ Stack trace:', error.stack); // âœ… FIXED: Added stack trace
            throw error;
        }
    }

    async _createInvoicePDF(order, user) {
        return new Promise((resolve, reject) => {
            try {
                console.log('ðŸ“„ Creating PDF document...');
                const doc = new PDFDocument({
                    margin: 50,
                    size: 'A4'
                });

                const chunks = [];

                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => {
                    console.log('ðŸ“„ PDF generation completed');
                    resolve(Buffer.concat(chunks));
                });
                doc.on('error', (error) => {
                    console.error('âŒ PDF generation error:', error);
                    console.error('âŒ PDF error stack:', error.stack); // âœ… FIXED: Added stack trace
                    reject(error);
                });

                this._generateHeader(doc, order, 'AUTO-GENERATED');
                this._generateCustomerInfo(doc, order, user);
                this._generateInvoiceTable(doc, order);
                this._generateOrderSummary(doc, order);
                this._generateFooter(doc, order);

                doc.end();
            } catch (error) {
                console.error('âŒ PDF creation error:', error);
                console.error('âŒ PDF creation stack:', error.stack); // âœ… FIXED: Added stack trace
                reject(error);
            }
        });
    }

    _generateHeader(doc, order, invoiceType) {
        // âœ… FIXED: Using RGB colors instead of hex for PDFKit compatibility
        const colors = {
            dark: [45, 55, 72],      // #2d3748
            gray: [102, 102, 102],   // #666666
            white: [255, 255, 255],  // #ffffff
            green: [16, 185, 129],   // #10b981
            blue: [59, 130, 246],    // #3b82f6
        };

        // Company Header
        doc.font(this.fonts.bold)
            .fontSize(20)
            .fillColor(colors.dark)
            .text('INVOICE', 50, 50);

        // Invoice type badge
        if (invoiceType) {
            const typeColor = invoiceType === 'AUTO-GENERATED' ? colors.green : colors.blue;
            doc.fillColor(typeColor)
                .rect(400, 45, 120, 20)
                .fill();

            doc.fillColor(colors.white)
                .fontSize(8)
                .text(invoiceType, 410, 51, { width: 100, align: 'center' });
        }

        // Invoice details
        doc.font(this.fonts.regular)
            .fontSize(10)
            .fillColor(colors.gray)
            .text(`Invoice #: INV-${order.orderNumber}`, 50, 80)
            .text(`Order #: ${order.orderNumber}`, 50, 95)
            .text(`Order Date: ${new Date(order.createdAt).toLocaleDateString()}`, 50, 110)
            .text(`Invoice Date: ${new Date().toLocaleDateString()}`, 50, 125);

        // Order Status - âœ… FIXED: Using RGB colors
        const statusColor = this._getStatusColorRGB(order.status);
        doc.fillColor(statusColor)
            .rect(400, 75, 100, 25)
            .fill();

        doc.fillColor(colors.white)
            .fontSize(10)
            .text(order.status.toUpperCase(), 420, 82, { width: 60, align: 'center' });

        // Company Info
        doc.fillColor(colors.dark)
            .fontSize(10)
            .text('iTech Store', 400, 120)
            .fontSize(8)
            .text('123 Electronics Street', 400, 135)
            .text('Tech City, TC 12345', 400, 147)
            .text('Phone: +91 9876543210', 400, 159)
            .text('Email: support@itech.com', 400, 171)
            .text('GSTIN: 07AABCU9603R1ZM', 400, 183);
    }

    _generateCustomerInfo(doc, order, user) {
        const colors = {
            dark: [45, 55, 72],
            gray: [102, 102, 102],
            white: [255, 255, 255]
        };

        const shipping = order.shippingAddress;

        doc.font(this.fonts.bold)
            .fontSize(12)
            .fillColor(colors.dark)
            .text('SHIPPING ADDRESS:', 50, 200);

        // Fixed address formatting
        doc.font(this.fonts.regular)
            .fontSize(10)
            .fillColor(colors.gray)
            .text(`${shipping.firstName} ${shipping.lastName}`, 50, 215)
            .text(shipping.addressLine1, 50, 230);

        if (shipping.addressLine2) {
            doc.text(shipping.addressLine2, 50, 245);
        }

        doc.text(`${shipping.city}, ${shipping.state} - ${shipping.pincode}`, 50, 260)
            .text(shipping.country, 50, 275)
            .text(`Phone: ${shipping.phone}`, 50, 290)
            .text(`Email: ${shipping.email || user.email}`, 50, 305);

        // Customer info box
        doc.font(this.fonts.bold)
            .fontSize(12)
            .fillColor(colors.dark)
            .text('CUSTOMER INFORMATION:', 250, 200);

        doc.font(this.fonts.regular)
            .fontSize(10)
            .fillColor(colors.gray)
            .text(`Customer ID: ${user._id}`, 250, 215)
            .text(`Name: ${user.firstName} ${user.lastName || ''}`, 250, 230)
            .text(`Email: ${user.email}`, 250, 245)
            .text(`Phone: ${shipping.phone}`, 250, 260);

        // GST Info if available
        if (order.gstInfo && order.gstInfo.gstNumber) {
            doc.font(this.fonts.bold)
                .fontSize(10)
                .fillColor(colors.dark)
                .text(`GSTIN: ${order.gstInfo.gstNumber}`, 250, 280);

            if (order.gstInfo.businessName) {
                doc.text(`Business: ${order.gstInfo.businessName}`, 250, 295);
            }
        }
    }

    // In your _generateInvoiceTable method, update to use available fields:
    _generateInvoiceTable(doc, order) {
        const colors = {
            dark: [45, 55, 72],
            gray: [102, 102, 102],
            white: [255, 255, 255],
            lightGray: [248, 249, 250]
        };

        const tableTop = 350;

        // Table Header
        doc.fillColor(colors.dark)
            .rect(50, tableTop, 500, 20)
            .fill();

        doc.fillColor(colors.white)
            .fontSize(10)
            .font(this.fonts.bold)
            .text('Product', 60, tableTop + 5)
            .text('Type', 250, tableTop + 5)
            .text('Qty', 350, tableTop + 5)
            .text('Price', 400, tableTop + 5)
            .text('Amount', 470, tableTop + 5);

        // Table Rows
        let yPosition = tableTop + 30;

        order.items.forEach((item, index) => {
            // Check if we need new page before drawing
            if (yPosition > 650) {
                doc.addPage();
                yPosition = 50;
            }

            const rowColor = index % 2 === 0 ? colors.lightGray : colors.white;
            doc.fillColor(rowColor)
                .rect(50, yPosition, 500, 20)
                .fill();

            // Use ONLY the fields that exist in your Order items (no population needed)
            const productName = item.name || 'Product';
            const productType = item.productType || 'product';
            const quantity = item.quantity || 1;
            const price = item.price || 0;
            const total = price * quantity;

            doc.fillColor(colors.dark)
                .fontSize(9)
                .font(this.fonts.regular)
                .text(productName, 60, yPosition + 5, { width: 180 })
                .text(productType.toUpperCase(), 250, yPosition + 5, { width: 90 })
                .text(quantity.toString(), 350, yPosition + 5, { width: 40, align: 'center' })
                .text(`â‚¹${price.toFixed(2)}`, 400, yPosition + 5, { width: 60, align: 'right' })
                .text(`â‚¹${total.toFixed(2)}`, 470, yPosition + 5, { width: 70, align: 'right' });

            yPosition += 20;
        });
    }

    _generateOrderSummary(doc, order) {
        const colors = {
            dark: [45, 55, 72],
            gray: [102, 102, 102]
        };

        const summaryTop = 450;
        const pricing = order.pricing || {};

        doc.fillColor(colors.dark)
            .font(this.fonts.bold)
            .fontSize(10)
            .text('ORDER SUMMARY:', 350, summaryTop);

        let currentY = summaryTop + 20;

        // Subtotal
        doc.text('Subtotal:', 350, currentY)
            .text(`â‚¹${(pricing.subtotal || 0).toFixed(2)}`, 470, currentY, { align: 'right' });
        currentY += 15;

        // Discount
        if (pricing.discount > 0) {
            doc.text('Discount:', 350, currentY)
                .text(`-â‚¹${(pricing.discount || 0).toFixed(2)}`, 470, currentY, { align: 'right' });
            currentY += 15;
        }

        // Shipping
        doc.text('Shipping:', 350, currentY)
            .text(`â‚¹${(pricing.shipping || 0).toFixed(2)}`, 470, currentY, { align: 'right' });
        currentY += 15;

        // Tax
        doc.text('Tax:', 350, currentY)
            .text(`â‚¹${(pricing.tax || 0).toFixed(2)}`, 470, currentY, { align: 'right' });
        currentY += 20;

        // Total
        doc.fontSize(12)
            .text('TOTAL:', 350, currentY)
            .text(`â‚¹${(pricing.total || 0).toFixed(2)}`, 470, currentY, { align: 'right' });
        currentY += 25;

        // Payment Info
        doc.fontSize(10)
            .text(`Payment Status: ${(order.payment?.status || 'unknown').toUpperCase()}`, 350, currentY);
        currentY += 15;

        doc.text(`Payment Method: ${order.paymentMethod || 'razorpay'}`, 350, currentY);
    }

    _generateFooter(doc, order) {
        const colors = {
            gray: [102, 102, 102]
        };

        const footerY = 750;

        doc.font(this.fonts.regular)
            .fontSize(8)
            .fillColor(colors.gray)
            .text('Thank you for your purchase!', 50, footerY, { align: 'center' })
            .text('This is a computer-generated invoice. No signature required.', 50, footerY + 12, { align: 'center' })
            .text(`Invoice generated automatically on: ${new Date().toLocaleString()}`, 50, footerY + 24, { align: 'center' })
            .text('For any queries, contact: support@itech.com | +91 9876543210', 50, footerY + 36, { align: 'center' });
    }

    // âœ… FIXED: RGB color version for PDFKit compatibility
    _getStatusColorRGB(status) {
        const colors = {
            'pending': [245, 158, 11],     // #f59e0b
            'confirmed': [16, 185, 129],   // #10b981
            'processing': [59, 130, 246],  // #3b82f6
            'shipped': [139, 92, 246],     // #8b5cf6
            'delivered': [5, 150, 105],    // #059669
            'cancelled': [239, 68, 68],    // #ef4444
            'refunded': [107, 114, 128]    // #6b7280
        };
        return colors[status] || [107, 114, 128]; // Default gray
    }

    // Keep hex version for reference (not used in PDF)
    _getStatusColor(status) {
        const colors = {
            'pending': '#f59e0b',
            'confirmed': '#10b981',
            'processing': '#3b82f6',
            'shipped': '#8b5cf6',
            'delivered': '#059669',
            'cancelled': '#ef4444',
            'refunded': '#6b7280'
        };
        return colors[status] || '#6b7280';
    }
}

// âœ… FIXED: Create instance and export with initialization
const invoiceGenerator = new InvoiceGenerator();

// Initialize on module load
invoiceGenerator.init().catch(console.error);

module.exports = invoiceGenerator;